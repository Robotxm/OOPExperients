# 题目二：定义函数 `atoi()`

## 题目原文

Write a function `atoi(const char*)` that takes a string containing digits and returns the corresponding `int`. For example, `atoi("123")` is *123*. Modify `atoi()` to handle C++ octal and hexadecimal notation in addition to plain decimal numbers. Modify `atoi()` to handle the C++ character constant notation.

## 题目翻译

编写函数 `atoi(const char*)`，它接受一个包含数字的字符串作为参数并返回对应的 `int` 值。例如，`atoi("123")` 返回 123。修改 `atoi()` 使其在处理普通十进制数字之外还能处理符合 C++ 标准要求的八进制和十六进制表示的数字。修改 `atoi()` 使其能处理符合 C++ 标准要求的字符常量表示。

## 题目解析

这道题实际上是让我们自己实现 `atoi` 函数。由于题目要求需要支持多种输入格式，因此我们将整个过程分为拆分为两部分实现。

第一部分为预处理，即处理题目中叙述的类似于 `0\x312` 这种输入字符串。`\x31` 需要被视为一个合法的 16 进制表示的字符 `1`，因此这个输入实际上是 `012`。同时也会出现类似 `\061` 被视为合法的 8 进制表示的字符的情况。对于这些内容，首先利用正则表达式来匹配，将匹配到的所有结果放入一个 `set` 中（采用 `set` 是因为它能保证容器中所有内容不重复），然后再遍历 `set`，替换输入字符串中的所有对应内容。这部分内容对应的是代码中的 `PreProcess()` 函数。

第二部分就是题目要求的 `atoi` 函数了。经过预处理后，现在的输入字符串中的数字部分都是 0~9 的字符了。接下来开始转换。首先是跳过所有的空白符，然后根据当前字符决定数字的正负性。由于题目要求该函数支持八进制、十进制和十六进制，因此我们需要检测数字的进制。这部分可以直接看代码，不再赘述。

另外，我们需要考虑数字溢出的处理。首先确定极值，这个极值除以进制的余数就是合规的最后一位数字，商就是除了最后一位以外，其他部分的最大值。同时引入一个 `is_overflowed` 作为溢出标志。这几个值留作备用。

开始真正处理数字部分。显然如果读到非数字字符，或者扫到的数字大于上面判断出来的进制，我们直接 `break` 掉就好。对于 0~9 的数字字符，将其减去 `'0'` 之后就是真正的值；对于 A~F 的数字字符（用于十六进制），根据其大小写减去 `'A'` 或者 `'a'` 就是其实际值。

然后是溢出检测，如果出现当前溢出标志为 `true`、目前的结果已经大于上面的最大值，或者目前的结果等于最大值但是下一位大于上面的合规的最后一位数字这三种情况，那么都视为溢出，溢出标志置为 `true`。这里考虑溢出标志的原因是分析前面数字是可能已经溢出了，这样的话继续把字符串扫完就是了。

最后是结果处理，如果溢出就输出之前的极值表示溢出，否则就输出正常的结果。记得给负数加上负号。