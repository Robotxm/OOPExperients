# 题目：桌面计算器

## 题目原文

结合第 8、9 章、习题 8.5.3 的要求，对第 6 章的桌面计算器按照以下要求改造实现：

1. 采用多个头文件、多个实现文件的方式实现完整程序（使得源代码的物理结构和逻辑结构保持一致）；

2. 输入中每遇到一个分号或回车（'\n'）就认为一个完整表达式结束，并将该完整表达式记作一行。在处理过程中累计行数（和行号）；

3. 对于输入中存在的错误，除了提示错误现象外，还需提示相应的出错行号（即表达式的序号）。

4. 必须支持命令行参数，以指明从何处读取所有表达式。

	- 命令行参数中的第 2 项开始，指定 0~多个输入文件之路径。输入文件就是普通的文本文件，其中预先输入了若干表达式，内容及格式 均与来自标准输入的完全相同。

	- 若命令行参数未指明输入文件，则程序从标准输入设备（`cin`）读取表达式。
	
	- 若命令行指明了 1~N 个输入文件，则程序依次从这些文件读入表达式，并按照读到的顺序依次处理他们。

## 题目解析

刚拿到题的时候心里一惊，怎么上课 C++，作业编译原理，不过仔细看了下之后和编译原理没有太大关系。

计算器的所有主体部分的实现（包括词法分析和语法分析等）在教材第 6 章里已经完全给出，这些代码直接搬过来就行。注意教材 8.3.3 节中的 `Skip()` 函数是有问题的，`switch-case` 中应当直接 `return` 而不能多进行一次 `input->get(ch)`。另外就是如果当前流为空，或者当前字符的 Token 是 `PRINT` 的话是不应该执行 `Skip()` 的，这一点教材中的代码也没有考虑到。

先简单说说我对这道题的实现，根据要求是按照命名空间将各个模块分开（包括但不限于词法分析、语法分析、符号表和错误处理等），我的做法更为激进一点，除了分成不同的命名空间，还将各个模块以类的形式实现，这样更加符合面向对象的思想。

然后我们依次来看各项要求。要求 1 的多模块实现方式在之前的实验中已经涉及，并且指导文档中写得也比较详细，这里就不展开说了。

要求 2 需要我们实现表达式数量的记录，这个是我个人认为的难点，记录的位置比较关键，如果位置不正确的话会导致数量有误。首先我们明确一点，空表达式（只有分号或者回车，没有其他内容的表达式）是不统计的（实际上我觉得严格来讲是**不应该**统计的，一是统计空表达式没有意义，就像编译器会忽略代码中的大部分换行一样；二是像 Mathematica 这种数学软件也没有统计空表达式）。这样的话我们需要统计的只有合法表达式和非法表达式两种了。

那什么是合法表达式呢？显然，能够被正确求值并输出的表达式才称得上“合法”，因此第一个需要记录数量的地方就是表达式在被正确输出之后，也就是教材中 `cout << expr(false) << "\n"` 这一行之后。相对地，非法表达式就是能引发异常的表达式，由于异常可能会在表达式的开头（`)2+3`）、中间（`1/0`）和结尾（`1+2*`）的任何一个地方引发，为了统一，我们选择在错误处理模块中统计这个数量。课本上的错误处理使用的 `error()` 函数，我在实现时用的是异常（Exception）。

要求 3 需要在要求 2 的基础上完成，思路挺简单，这里不多讲。

要求 4 需要我们支持从文件读入表达式。无论是文件还是标准输入，在 C++ 中都可以抽象为“流”，`cin` 本身就是一个 `istream` 对象，而文件流 `ifstream` 又是派生自 `istream` 的，因此我们可以将数据来源直接设置为一个 `istream`，然后根据需要决定传入 `cin` 还是文件流。

接下来说一些实现上的细节。前面提到，我将各个模块抽象为了不同的类，考虑到在程序整个生命周期中各个模块只需要一个实例，因此我采用了单例设计模式确保这些类有且只能有一个实例。单例模式不是学校课程要求的内容，相关内容请自行查阅相关资料。当然也可以直接忽略。

由于采用了 `ifstream` 作为内部的数据来源，因此对于词法分析器，我们需要提前设置其数据来源，这里我为词法分析器 `Lexer` 类增加了 `SetInput()` 和 `Start()` 两个函数，前者用于设置数据来源，后者用于开始实际上的分析过程。另外在 `Start()` 函数里会检测是否已经设置数据来源，如果没有的话会抛出异常。

词法分析中，教材上的示例认为 `2+3)` 属于合法表达式，但实际上是不对的。对于这种错误的判断，请看 `lexer.cpp` 的 `Start()` 函数实现。

语法分析部分，对于一元运算，教材中只实现了一元减（也就是操作数为负数的情况，比如 `1+-5`），我增加了一个一元加的实现。这个逻辑和一元减几乎相同，直接看代码是完全可以理解的。

根据指导文档的要求，还需要实现一个符号表。教材中直接使用了一个全局的 `map` 对象。而我在实现的时候将其包装成了一个类，通过暴露的 `Get()` 和 `Put()` 函数来实现添加变量和取值操作。考虑到有内置的符号变量 `pi` 和 `e`，因此所有对这两个符号变量的赋值操作都是被禁止的，代码中通过抛出异常来体现。另外，对于表达式 `2+A`，如果此时 `A` 不存在，那么应当视为表达式非法，并抛出一个异常。这里对于符号变量存在性的检查可以直接看代码，应当还是比较容易理解的。

错误处理方面，通过引入异常机制并配合前面提到的 `Skip()` 函数，可以确保在表达式有问题的时候不会返回一个本应不该存在的错误结果。根据题目要求，程序还应当记录错误数量。简单粗暴的做法是在 `catch` 语句块中记录。而我的实现中，定义了一个派生自 `std::exception` 的 `BaseException` 类，这个类可以看作是程序中所有可能的异常的“基类”，后续程序中定义的其他异常均派生自这个 `BaseException` 类。在这个类中我们可以用有一个静态成员 `count_`，在每次抛出异常时对其加 1。由于我们定义的其他异常都是这个类的派生类，因此很轻松就统计了所有错误数量。